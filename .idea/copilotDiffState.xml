<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/com/example/ev/model/FindRequest.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/example/ev/model/FindRequest.java" />
              <option name="originalContent" value="package com.example.ev.model;&#10;&#10;import lombok.Data;&#10;&#10;@Data&#10;public class FindRequest {&#10;    public static class LatLng {&#10;        public double latitude;&#10;        public double longitude;&#10;    }&#10;    private LatLng origin;&#10;    private LatLng destination;&#10;    /** current available range in miles (based on current SOC) */&#10;    private double currentRangeMiles;&#10;    /** state of charge 0-100 (percentage) */&#10;    private Double soc;&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.ev.model;&#10;&#10;import lombok.Data;&#10;import java.util.List;&#10;&#10;@Data&#10;public class FindRequest {&#10;    public static class LatLng {&#10;        public double latitude;&#10;        public double longitude;&#10;    }&#10;    private LatLng origin;&#10;    private LatLng destination;&#10;    private List&lt;LatLng&gt; intermediates; // Optional intermediate stops&#10;    /** current available range in miles (based on current SOC) */&#10;    private double currentRangeMiles;&#10;    /** state of charge 0-100 (percentage) */&#10;    private Double soc;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/example/ev/model/FindResponse.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/example/ev/model/FindResponse.java" />
              <option name="originalContent" value="package com.example.ev.model;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;@Data&#10;@AllArgsConstructor&#10;public class FindResponse {&#10;    private boolean reachableWithoutCharging;&#10;    private double totalRouteDistanceMiles;&#10;    private double remainingRangeAfterRoute;&#10;    private List&lt;Stop&gt; stops = new ArrayList&lt;&gt;();&#10;    private String encodedPolyline; // Add encoded polyline to response&#10;    private List&lt;RoutePoint&gt; routeSequence = new ArrayList&lt;&gt;(); // Sequential route points for frontend mapping&#10;&#10;    // Constructor for backward compatibility&#10;    public FindResponse(boolean reachableWithoutCharging, double totalRouteDistanceMiles,&#10;                       double remainingRangeAfterRoute, List&lt;Stop&gt; stops) {&#10;        this.reachableWithoutCharging = reachableWithoutCharging;&#10;        this.totalRouteDistanceMiles = totalRouteDistanceMiles;&#10;        this.remainingRangeAfterRoute = remainingRangeAfterRoute;&#10;        this.stops = stops;&#10;        this.encodedPolyline = null;&#10;        this.routeSequence = new ArrayList&lt;&gt;();&#10;    }&#10;&#10;    @Data&#10;    public static class Stop {&#10;        private double lat;&#10;        private double lon;&#10;        private String stationName;&#10;        private double distanceFromRoutePointMiles;&#10;        private Integer deviceId; // Add device_id from ChargePoint API&#10;    }&#10;&#10;    @Data&#10;    public static class RoutePoint {&#10;        private double lat;&#10;        private double lon;&#10;        private String type; // &quot;origin&quot;, &quot;intermediate&quot;, &quot;charging_station&quot;, &quot;destination&quot;&#10;&#10;        public RoutePoint(double lat, double lon, String type) {&#10;            this.lat = lat;&#10;            this.lon = lon;&#10;            this.type = type;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.ev.model;&#10;&#10;import lombok.AllArgsConstructor;&#10;import lombok.Data;&#10;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;&#10;@Data&#10;@AllArgsConstructor&#10;public class FindResponse {&#10;    private boolean reachableWithoutCharging;&#10;    private double totalRouteDistanceMiles;&#10;    private double remainingRangeAfterRoute;&#10;    private List&lt;Stop&gt; stops = new ArrayList&lt;&gt;();&#10;    private String encodedPolyline; // Add encoded polyline to response&#10;    private List&lt;RoutePoint&gt; routeSequence = new ArrayList&lt;&gt;(); // Sequential route points for frontend mapping&#10;&#10;    // Constructor for backward compatibility&#10;    public FindResponse(boolean reachableWithoutCharging, double totalRouteDistanceMiles,&#10;                       double remainingRangeAfterRoute, List&lt;Stop&gt; stops) {&#10;        this.reachableWithoutCharging = reachableWithoutCharging;&#10;        this.totalRouteDistanceMiles = totalRouteDistanceMiles;&#10;        this.remainingRangeAfterRoute = remainingRangeAfterRoute;&#10;        this.stops = stops;&#10;        this.encodedPolyline = null;&#10;        this.routeSequence = new ArrayList&lt;&gt;();&#10;    }&#10;&#10;    @Data&#10;    public static class Stop {&#10;        private double lat;&#10;        private double lon;&#10;        private String stationName;&#10;        private double distanceFromRoutePointMiles;&#10;        private Integer deviceId; // Add device_id from ChargePoint API&#10;        private Object rawStationData; // Store the complete raw station data from API&#10;        private List&lt;Object&gt; allRawStations = new ArrayList&lt;&gt;(); // All raw stations found at this search location&#10;    }&#10;&#10;    @Data&#10;    public static class RoutePoint {&#10;        private double lat;&#10;        private double lon;&#10;        private String type; // &quot;origin&quot;, &quot;intermediate&quot;, &quot;charging_station&quot;, &quot;destination&quot;&#10;&#10;        public RoutePoint(double lat, double lon, String type) {&#10;            this.lat = lat;&#10;            this.lon = lon;&#10;            this.type = type;&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/example/ev/service/RouteService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/example/ev/service/RouteService.java" />
              <option name="originalContent" value="package com.example.ev.service;&#10;&#10;import com.example.ev.model.FindRequest;&#10;import com.example.ev.model.FindResponse;&#10;import com.example.ev.util.Polyline;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.http.*;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.web.client.RestTemplate;&#10;&#10;import java.util.*;&#10;&#10;@Service&#10;@RequiredArgsConstructor&#10;public class RouteService {&#10;&#10;    private final RestTemplate restTemplate;&#10;&#10;    @Value(&quot;${google.routes.api.key}&quot;)&#10;    private String googleApiKey;&#10;&#10;    @Value(&quot;${chargepoint.map.api.url}&quot;)&#10;    private String chargepointApiUrl;&#10;&#10;    @Value(&quot;${ev.bufferPercent:0.30}&quot;)&#10;    private double bufferPercent;&#10;&#10;    @Value(&quot;${ev.chargePercent:0.80}&quot;)&#10;    private double chargePercent;&#10;&#10;    private final double KM_PER_MILE = 1.609344;&#10;&#10;    public FindResponse findChargingPlan(FindRequest req) throws Exception {&#10;        double currentRange = req.getCurrentRangeMiles();&#10;        double currentSoc = req.getSoc(); // SOC as percentage (0-100)&#10;&#10;        // Calculate full range based on current range and SOC&#10;        // If currentRangeMiles = 100 and SOC = 50%, then fullRange = 100 / 0.5 = 200&#10;        double fullRange = currentRange / (currentSoc / 100.0);&#10;&#10;        // Apply 30% buffer to current range - keep 30% as safety margin&#10;        // If current range is 450 miles, effective usable range is 315 miles (70% of 450)&#10;        double effectiveRange = currentRange * (1 - bufferPercent);&#10;&#10;        // Call Google Routes API to get route polyline and total distance&#10;        Map&lt;String, Object&gt; routeData = callGoogleRoutesApi(req);&#10;        if (routeData == null) {&#10;            throw new RuntimeException(&quot;No route returned from Google Routes API&quot;);&#10;        }&#10;&#10;        double totalMeters = ((Number) routeData.getOrDefault(&quot;distanceMeters&quot;, 0)).doubleValue();&#10;        double totalMiles = totalMeters / 1609.344;&#10;        List&lt;double[]&gt; polyline = (List&lt;double[]&gt;) routeData.get(&quot;polyline&quot;);&#10;        String encodedPolyline = (String) routeData.get(&quot;encodedPolyline&quot;);&#10;&#10;        FindResponse response = new FindResponse(false, totalMiles, 0.0, new ArrayList&lt;&gt;());&#10;        response.setEncodedPolyline(encodedPolyline);&#10;&#10;        // Initialize route sequence with origin&#10;        response.getRouteSequence().add(new FindResponse.RoutePoint(&#10;            req.getOrigin().latitude, req.getOrigin().longitude, &quot;origin&quot;&#10;        ));&#10;&#10;        // Check if destination is reachable without charging&#10;        // Compare effective range (with buffer) against total distance&#10;        if (effectiveRange &gt;= totalMiles) {&#10;            response.setReachableWithoutCharging(true);&#10;            response.setRemainingRangeAfterRoute(effectiveRange - totalMiles);&#10;&#10;            // Add intermediate stops to route sequence if any&#10;            if (req.getIntermediates() != null) {&#10;                for (int i = 0; i &lt; req.getIntermediates().size(); i++) {&#10;                    FindRequest.LatLng intermediate = req.getIntermediates().get(i);&#10;                    response.getRouteSequence().add(new FindResponse.RoutePoint(&#10;                        intermediate.latitude, intermediate.longitude, &quot;intermediate&quot;&#10;                    ));&#10;                }&#10;            }&#10;&#10;            // Add destination to route sequence&#10;            response.getRouteSequence().add(new FindResponse.RoutePoint(&#10;                req.getDestination().latitude, req.getDestination().longitude, &quot;destination&quot;&#10;            ));&#10;&#10;            return response;&#10;        }&#10;&#10;        // Need charging - recursively find charging stations and plan route&#10;        // Track remaining intermediate stops (initially all of them)&#10;        List&lt;FindRequest.LatLng&gt; remainingIntermediates = req.getIntermediates() != null ?&#10;            new ArrayList&lt;&gt;(req.getIntermediates()) : new ArrayList&lt;&gt;();&#10;&#10;        return findChargingStopsRecursively(req, polyline, effectiveRange, fullRange, response, remainingIntermediates);&#10;    }&#10;&#10;    private FindResponse findChargingStopsRecursively(FindRequest req, List&lt;double[]&gt; polyline,&#10;                                                     double currentEffectiveRange, double fullRange,&#10;                                                     FindResponse response, List&lt;FindRequest.LatLng&gt; remainingIntermediates) throws Exception {&#10;&#10;        double accumulatedMiles = 0;&#10;        int lastReachableIndex = 0;&#10;        List&lt;FindRequest.LatLng&gt; reachedIntermediates = new ArrayList&lt;&gt;();&#10;&#10;        // Iterate through polyline points&#10;        for (int i = 1; i &lt; polyline.size(); i++) {&#10;            double[] previousPoint = polyline.get(i - 1);&#10;            double[] currentPoint = polyline.get(i);&#10;            double segmentMiles = haversineMiles(previousPoint[0], previousPoint[1],&#10;                    currentPoint[0], currentPoint[1]);&#10;            accumulatedMiles += segmentMiles;&#10;&#10;            if (accumulatedMiles &lt;= currentEffectiveRange) {&#10;                lastReachableIndex = i;&#10;&#10;                // Check if we've reached any intermediate stops at this point&#10;                List&lt;FindRequest.LatLng&gt; justReached = checkAndUpdateReachedIntermediates(currentPoint, remainingIntermediates);&#10;                reachedIntermediates.addAll(justReached);&#10;            } else {&#10;                // Add any intermediate stops we reached before needing to charge&#10;                for (FindRequest.LatLng reached : reachedIntermediates) {&#10;                    response.getRouteSequence().add(new FindResponse.RoutePoint(&#10;                        reached.latitude, reached.longitude, &quot;intermediate&quot;&#10;                    ));&#10;                }&#10;&#10;                // Cannot reach current point, search for charging station at last reachable point&#10;                double[] searchPoint = polyline.get(lastReachableIndex);&#10;                FindResponse.Stop chargingStation = searchForChargingStation(searchPoint[0], searchPoint[1]);&#10;&#10;                if (chargingStation == null) {&#10;                    // No station found, try previous polyline points with distance-based search to avoid gaps&#10;                    // Instead of skipping fixed number of points, skip based on distance to ensure coverage&#10;                    double searchRadiusKm = 10.0; // Our search radius is 10km (7km half-radius × 2)&#10;                    double maxGapKm = searchRadiusKm * 0.8; // Allow 80% overlap (8km gaps max)&#10;&#10;                    double accumulatedDistance = 0;&#10;                    for (int j = lastReachableIndex - 1; j &gt;= 0 &amp;&amp; j &gt;= lastReachableIndex - 300; j--) {&#10;                        double[] currentSearchPoint = polyline.get(j);&#10;                        double[] previousSearchPoint = polyline.get(j + 1);&#10;&#10;                        // Calculate distance from previous search point&#10;                        double segmentDistanceKm = haversineMiles(currentSearchPoint[0], currentSearchPoint[1],&#10;                                previousSearchPoint[0], previousSearchPoint[1]) * KM_PER_MILE;&#10;                        accumulatedDistance += segmentDistanceKm;&#10;&#10;                        // Only search if we've moved far enough to avoid too much overlap&#10;                        if (accumulatedDistance &gt;= maxGapKm) {&#10;                            chargingStation = searchForChargingStation(currentSearchPoint[0], currentSearchPoint[1]);&#10;                            if (chargingStation != null) {&#10;                                System.out.println(&quot;Found charging station at polyline point &quot; + j +&#10;                                    &quot; (distance gap: &quot; + String.format(&quot;%.2f&quot;, accumulatedDistance) + &quot; km)&quot;);&#10;                                break;&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                if (chargingStation == null) {&#10;                    response.setReachableWithoutCharging(false);&#10;                    response.setRemainingRangeAfterRoute(0);&#10;                    // Add final destination even if unreachable for route visualization&#10;                    response.getRouteSequence().add(new FindResponse.RoutePoint(&#10;                        req.getDestination().latitude, req.getDestination().longitude, &quot;destination&quot;&#10;                    ));&#10;                    return response;&#10;                }&#10;&#10;                response.getStops().add(chargingStation);&#10;&#10;                // Add charging station to route sequence&#10;                response.getRouteSequence().add(new FindResponse.RoutePoint(&#10;                    chargingStation.getLat(), chargingStation.getLon(), &quot;charging_station&quot;&#10;                ));&#10;&#10;                // Calculate new route from charging station to destination&#10;                FindRequest newRequest = new FindRequest();&#10;                FindRequest.LatLng stationLocation = new FindRequest.LatLng();&#10;                stationLocation.latitude = chargingStation.getLat();&#10;                stationLocation.longitude = chargingStation.getLon();&#10;                newRequest.setOrigin(stationLocation);&#10;                newRequest.setDestination(req.getDestination());&#10;&#10;                // Only include remaining intermediate stops that haven't been reached yet&#10;                if (!remainingIntermediates.isEmpty()) {&#10;                    newRequest.setIntermediates(new ArrayList&lt;&gt;(remainingIntermediates));&#10;                }&#10;&#10;                // After charging, range is restored to fullRange * chargePercent with buffer applied&#10;                double newRange = fullRange * chargePercent;&#10;                double newEffectiveRange = newRange * (1 - bufferPercent);&#10;                newRequest.setCurrentRangeMiles(newRange);&#10;                // Set SOC to chargePercent * 100 (e.g., 80% charge)&#10;                newRequest.setSoc(chargePercent * 100);&#10;&#10;                // Get new route from station to destination (with remaining intermediates)&#10;                Map&lt;String, Object&gt; newRouteData = callGoogleRoutesApi(newRequest);&#10;                if (newRouteData == null) {&#10;                    throw new RuntimeException(&quot;No route from charging station to destination&quot;);&#10;                }&#10;&#10;                double remainingMeters = ((Number) newRouteData.getOrDefault(&quot;distanceMeters&quot;, 0)).doubleValue();&#10;                double remainingMiles = remainingMeters / 1609.344;&#10;                List&lt;double[]&gt; newPolyline = (List&lt;double[]&gt;) newRouteData.get(&quot;polyline&quot;);&#10;&#10;                if (newEffectiveRange &gt;= remainingMiles) {&#10;                    // Can reach destination from this charging station&#10;                    response.setReachableWithoutCharging(true);&#10;                    response.setRemainingRangeAfterRoute(newEffectiveRange - remainingMiles);&#10;&#10;                    // Add any remaining intermediate stops to route sequence&#10;                    if (remainingIntermediates != null) {&#10;                        for (FindRequest.LatLng intermediate : remainingIntermediates) {&#10;                            response.getRouteSequence().add(new FindResponse.RoutePoint(&#10;                                intermediate.latitude, intermediate.longitude, &quot;intermediate&quot;&#10;                            ));&#10;                        }&#10;                    }&#10;&#10;                    // Add destination to route sequence&#10;                    response.getRouteSequence().add(new FindResponse.RoutePoint(&#10;                        req.getDestination().latitude, req.getDestination().longitude, &quot;destination&quot;&#10;                    ));&#10;&#10;                    return response;&#10;                } else {&#10;                    // Need more charging stations, continue recursively with remaining intermediates&#10;                    return findChargingStopsRecursively(newRequest, newPolyline, newEffectiveRange, fullRange, response, remainingIntermediates);&#10;                }&#10;            }&#10;        }&#10;&#10;        // If we reach here, the route is complete without needing more charging&#10;        // Add any remaining intermediate stops that were reached&#10;        for (FindRequest.LatLng reached : reachedIntermediates) {&#10;            response.getRouteSequence().add(new FindResponse.RoutePoint(&#10;                reached.latitude, reached.longitude, &quot;intermediate&quot;&#10;            ));&#10;        }&#10;&#10;        // Add remaining intermediate stops if any&#10;        if (remainingIntermediates != null) {&#10;            for (FindRequest.LatLng intermediate : remainingIntermediates) {&#10;                response.getRouteSequence().add(new FindResponse.RoutePoint(&#10;                    intermediate.latitude, intermediate.longitude, &quot;intermediate&quot;&#10;                ));&#10;            }&#10;        }&#10;&#10;        // Add destination to route sequence&#10;        response.getRouteSequence().add(new FindResponse.RoutePoint(&#10;            req.getDestination().latitude, req.getDestination().longitude, &quot;destination&quot;&#10;        ));&#10;&#10;        response.setReachableWithoutCharging(true);&#10;        return response;&#10;    }&#10;&#10;    /**&#10;     * Check if the current point is close to any remaining intermediate stops&#10;     * and remove them from the remaining list if reached&#10;     */&#10;    private List&lt;FindRequest.LatLng&gt; checkAndUpdateReachedIntermediates(double[] currentPoint, List&lt;FindRequest.LatLng&gt; remainingIntermediates) {&#10;        double reachThresholdMiles = 1.0; // Consider intermediate reached if within 1 mile&#10;&#10;        List&lt;FindRequest.LatLng&gt; justReached = new ArrayList&lt;&gt;();&#10;        Iterator&lt;FindRequest.LatLng&gt; iterator = remainingIntermediates.iterator();&#10;        while (iterator.hasNext()) {&#10;            FindRequest.LatLng intermediate = iterator.next();&#10;            double distance = haversineMiles(currentPoint[0], currentPoint[1],&#10;                    intermediate.latitude, intermediate.longitude);&#10;&#10;            if (distance &lt;= reachThresholdMiles) {&#10;                justReached.add(intermediate);&#10;                iterator.remove(); // Remove this intermediate as we've reached it&#10;                System.out.println(&quot;Reached intermediate stop at: &quot; + intermediate.latitude + &quot;, &quot; + intermediate.longitude);&#10;            }&#10;        }&#10;&#10;        return justReached;&#10;    }&#10;&#10;    private Map&lt;String, Object&gt; callGoogleRoutesApi(FindRequest req) {&#10;        String url = &quot;https://routes.googleapis.com/directions/v2:computeRoutes&quot;;&#10;&#10;        // Create request payload matching the exact structure from your curl example&#10;        Map&lt;String, Object&gt; payload = new HashMap&lt;&gt;();&#10;&#10;        Map&lt;String, Object&gt; origin = Map.of(&#10;                &quot;location&quot;, Map.of(&#10;                        &quot;latLng&quot;, Map.of(&#10;                                &quot;latitude&quot;, req.getOrigin().latitude,&#10;                                &quot;longitude&quot;, req.getOrigin().longitude&#10;                        )&#10;                )&#10;        );&#10;&#10;        Map&lt;String, Object&gt; destination = Map.of(&#10;                &quot;location&quot;, Map.of(&#10;                        &quot;latLng&quot;, Map.of(&#10;                                &quot;latitude&quot;, req.getDestination().latitude,&#10;                                &quot;longitude&quot;, req.getDestination().longitude&#10;                        )&#10;                )&#10;        );&#10;&#10;        payload.put(&quot;origin&quot;, origin);&#10;        payload.put(&quot;destination&quot;, destination);&#10;&#10;        // Add intermediates if provided&#10;        if (req.getIntermediates() != null &amp;&amp; !req.getIntermediates().isEmpty()) {&#10;            List&lt;Map&lt;String, Object&gt;&gt; intermediates = new ArrayList&lt;&gt;();&#10;            for (FindRequest.LatLng intermediate : req.getIntermediates()) {&#10;                Map&lt;String, Object&gt; intermediateLocation = Map.of(&#10;                        &quot;location&quot;, Map.of(&#10;                                &quot;latLng&quot;, Map.of(&#10;                                        &quot;latitude&quot;, intermediate.latitude,&#10;                                        &quot;longitude&quot;, intermediate.longitude&#10;                                )&#10;                        )&#10;                );&#10;                intermediates.add(intermediateLocation);&#10;            }&#10;            payload.put(&quot;intermediates&quot;, intermediates);&#10;        }&#10;&#10;        payload.put(&quot;travelMode&quot;, &quot;DRIVE&quot;);&#10;        payload.put(&quot;routingPreference&quot;, &quot;TRAFFIC_AWARE_OPTIMAL&quot;);&#10;//        payload.put(&quot;polylineQuality&quot;, &quot;HIGH_QUALITY&quot;);&#10;&#10;        // Set headers exactly as specified in your curl example&#10;        HttpHeaders headers = new HttpHeaders();&#10;        headers.setContentType(MediaType.APPLICATION_JSON);&#10;        headers.set(&quot;X-Goog-Api-Key&quot;, googleApiKey);&#10;        headers.set(&quot;X-Goog-FieldMask&quot;, &quot;routes.distanceMeters,routes.polyline.encodedPolyline&quot;);&#10;&#10;        HttpEntity&lt;Map&lt;String, Object&gt;&gt; entity = new HttpEntity&lt;&gt;(payload, headers);&#10;&#10;        try {&#10;            ResponseEntity&lt;String&gt; response = restTemplate.postForEntity(url, entity, String.class);&#10;            if (!response.getStatusCode().is2xxSuccessful()) {&#10;                System.err.println(&quot;Google Routes API error: &quot; + response.getStatusCode());&#10;                return null;&#10;            }&#10;&#10;            // Parse JSON response&#10;            com.fasterxml.jackson.databind.ObjectMapper objectMapper = new com.fasterxml.jackson.databind.ObjectMapper();&#10;            com.fasterxml.jackson.databind.JsonNode root = objectMapper.readTree(response.getBody());&#10;&#10;            com.fasterxml.jackson.databind.JsonNode routeNode = root.path(&quot;routes&quot;).get(0);&#10;            if (routeNode == null) return null;&#10;&#10;            double distanceMeters = routeNode.path(&quot;distanceMeters&quot;).asDouble(0);&#10;            String encodedPolyline = routeNode.path(&quot;polyline&quot;).path(&quot;encodedPolyline&quot;).asText();&#10;&#10;            List&lt;double[]&gt; polyline = new ArrayList&lt;&gt;();&#10;            if (encodedPolyline != null &amp;&amp; !encodedPolyline.isEmpty()) {&#10;                polyline = Polyline.decode(encodedPolyline);&#10;            }&#10;&#10;            Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();&#10;            result.put(&quot;distanceMeters&quot;, distanceMeters);&#10;            result.put(&quot;polyline&quot;, polyline);&#10;            System.out.println(&quot;polyline &quot; + polyline);&#10;            result.put(&quot;encodedPolyline&quot;, encodedPolyline); // Add encoded polyline to result&#10;&#10;            return result;&#10;&#10;        } catch (Exception ex) {&#10;            System.err.println(&quot;Error calling Google Routes API: &quot; + ex.getMessage());&#10;            ex.printStackTrace();&#10;            return null;&#10;        }&#10;    }&#10;&#10;    private FindResponse.Stop searchForChargingStation(double lat, double lon) {&#10;        double halfKm = 7.0; // half of 5 km (so total box = 10 km height × 10 km width)&#10;&#10;        // Approximate conversion factors&#10;        double kmPerDegLat = 110.574; // ~ km per degree latitude&#10;        double kmPerDegLon = 111.320 * Math.cos(Math.toRadians(lat)); // ~ km per degree longitude at this latitude&#10;&#10;        // Convert km to degrees&#10;        double dLat = halfKm / kmPerDegLat;&#10;        double dLon = halfKm / kmPerDegLon;&#10;&#10;        // Bounding box corners&#10;        double neLat = lat + dLat;&#10;        double neLon = lon + dLon;&#10;        double swLat = lat - dLat;&#10;        double swLon = lon - dLon;&#10;&#10;        // Create payload matching your curl example structure&#10;        Map&lt;String, Object&gt; stationList = new HashMap&lt;&gt;();&#10;        stationList.put(&quot;screen_width&quot;, 417.5);&#10;        stationList.put(&quot;screen_height&quot;, 548);&#10;        stationList.put(&quot;ne_lat&quot;, neLat);&#10;        stationList.put(&quot;ne_lon&quot;, neLon);&#10;        stationList.put(&quot;sw_lat&quot;, swLat);&#10;        stationList.put(&quot;sw_lon&quot;, swLon);&#10;        stationList.put(&quot;page_size&quot;, 10);&#10;        stationList.put(&quot;page_offset&quot;, &quot;&quot;);&#10;        stationList.put(&quot;sort_by&quot;, &quot;distance&quot;);&#10;        stationList.put(&quot;reference_lat&quot;, lat);&#10;        stationList.put(&quot;reference_lon&quot;, lon);&#10;        stationList.put(&quot;include_map_bound&quot;, true);&#10;&#10;        // Add filters for available DC fast charging stations&#10;        Map&lt;String, Object&gt; filter = new HashMap&lt;&gt;();&#10;        filter.put(&quot;status_available&quot;, true);&#10;        filter.put(&quot;dc_fast_charging&quot;, true);&#10;        stationList.put(&quot;filter&quot;, filter);&#10;        stationList.put(&quot;bound_output&quot;, true);&#10;&#10;        Map&lt;String, Object&gt; payload = Map.of(&quot;station_list&quot;, stationList);&#10;&#10;        // Set headers exactly as specified in your curl example&#10;        HttpHeaders headers = new HttpHeaders();&#10;        headers.setContentType(MediaType.APPLICATION_JSON);&#10;        headers.set(&quot;accept&quot;, &quot;*/*&quot;);&#10;        headers.set(&quot;accept-language&quot;, &quot;en-GB&quot;);&#10;        HttpEntity&lt;Map&lt;String, Object&gt;&gt; entity = new HttpEntity&lt;&gt;(payload, headers);&#10;&#10;        try {&#10;            ResponseEntity&lt;String&gt; response = restTemplate.postForEntity(chargepointApiUrl, entity, String.class);&#10;            System.out.println(&quot;pk&quot; + response);&#10;            if (!response.getStatusCode().is2xxSuccessful()) {&#10;                System.err.println(&quot;ChargePoint API error: &quot; + response.getStatusCode());&#10;                return null;&#10;            }&#10;&#10;            com.fasterxml.jackson.databind.ObjectMapper objectMapper = new com.fasterxml.jackson.databind.ObjectMapper();&#10;            com.fasterxml.jackson.databind.JsonNode root = objectMapper.readTree(response.getBody());&#10;&#10;            com.fasterxml.jackson.databind.JsonNode stations = root.path(&quot;station_list&quot;).path(&quot;stations&quot;);&#10;            if (stations.isArray() &amp;&amp; stations.size() &gt; 0) {&#10;                com.fasterxml.jackson.databind.JsonNode firstStation = stations.get(0);&#10;&#10;                double stationLat = firstStation.path(&quot;lat&quot;).asDouble(firstStation.path(&quot;latitude&quot;).asDouble());&#10;                double stationLon = firstStation.path(&quot;lon&quot;).asDouble(firstStation.path(&quot;longitude&quot;).asDouble());&#10;                String stationName = firstStation.path(&quot;name&quot;).asText(&#10;                        firstStation.path(&quot;station_name&quot;).asText(&quot;ChargePoint Station&quot;)&#10;                );&#10;                Integer deviceId = firstStation.path(&quot;device_id&quot;).asInt(0);&#10;&#10;                FindResponse.Stop stop = new FindResponse.Stop();&#10;                stop.setLat(stationLat);&#10;                stop.setLon(stationLon);&#10;                stop.setStationName(stationName);&#10;                stop.setDistanceFromRoutePointMiles(haversineMiles(lat, lon, stationLat, stationLon));&#10;                stop.setDeviceId(deviceId); // Set the device_id from API response&#10;                return stop;&#10;            }&#10;&#10;            return null;&#10;&#10;        } catch (Exception ex) {&#10;            System.err.println(&quot;Error calling ChargePoint API: &quot; + ex.getMessage());&#10;            ex.printStackTrace();&#10;            return null;&#10;        }&#10;    }&#10;&#10;    private double haversineMiles(double lat1, double lon1, double lat2, double lon2) {&#10;        double R = 3958.8; // Earth radius in miles&#10;        double dLat = Math.toRadians(lat2 - lat1);&#10;        double dLon = Math.toRadians(lon2 - lon1);&#10;        double a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +&#10;                Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2)) *&#10;                Math.sin(dLon / 2) * Math.sin(dLon / 2);&#10;        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));&#10;        return R * c;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.ev.service;&#10;&#10;import com.example.ev.model.FindRequest;&#10;import com.example.ev.model.FindResponse;&#10;import com.example.ev.util.Polyline;&#10;import lombok.RequiredArgsConstructor;&#10;import org.springframework.beans.factory.annotation.Value;&#10;import org.springframework.http.*;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.web.client.RestTemplate;&#10;&#10;import java.util.*;&#10;&#10;@Service&#10;@RequiredArgsConstructor&#10;public class RouteService {&#10;&#10;    private final RestTemplate restTemplate;&#10;&#10;    @Value(&quot;${google.routes.api.key}&quot;)&#10;    private String googleApiKey;&#10;&#10;    @Value(&quot;${chargepoint.map.api.url}&quot;)&#10;    private String chargepointApiUrl;&#10;&#10;    @Value(&quot;${ev.bufferPercent:0.30}&quot;)&#10;    private double bufferPercent;&#10;&#10;    @Value(&quot;${ev.chargePercent:0.80}&quot;)&#10;    private double chargePercent;&#10;&#10;    private final double KM_PER_MILE = 1.609344;&#10;&#10;    public FindResponse findChargingPlan(FindRequest req) throws Exception {&#10;        double currentRange = req.getCurrentRangeMiles();&#10;        double currentSoc = req.getSoc(); // SOC as percentage (0-100)&#10;&#10;        // Calculate full range based on current range and SOC&#10;        // If currentRangeMiles = 100 and SOC = 50%, then fullRange = 100 / 0.5 = 200&#10;        double fullRange = currentRange / (currentSoc / 100.0);&#10;&#10;        // Apply 30% buffer to current range - keep 30% as safety margin&#10;        // If current range is 450 miles, effective usable range is 315 miles (70% of 450)&#10;        double effectiveRange = currentRange * (1 - bufferPercent);&#10;&#10;        // Call Google Routes API to get route polyline and total distance&#10;        Map&lt;String, Object&gt; routeData = callGoogleRoutesApi(req);&#10;        if (routeData == null) {&#10;            throw new RuntimeException(&quot;No route returned from Google Routes API&quot;);&#10;        }&#10;&#10;        double totalMeters = ((Number) routeData.getOrDefault(&quot;distanceMeters&quot;, 0)).doubleValue();&#10;        double totalMiles = totalMeters / 1609.344;&#10;        List&lt;double[]&gt; polyline = (List&lt;double[]&gt;) routeData.get(&quot;polyline&quot;);&#10;        String encodedPolyline = (String) routeData.get(&quot;encodedPolyline&quot;);&#10;&#10;        FindResponse response = new FindResponse(false, totalMiles, 0.0, new ArrayList&lt;&gt;());&#10;        response.setEncodedPolyline(encodedPolyline);&#10;&#10;        // Initialize route sequence with origin&#10;        response.getRouteSequence().add(new FindResponse.RoutePoint(&#10;            req.getOrigin().latitude, req.getOrigin().longitude, &quot;origin&quot;&#10;        ));&#10;&#10;        // Check if destination is reachable without charging&#10;        // Compare effective range (with buffer) against total distance&#10;        if (effectiveRange &gt;= totalMiles) {&#10;            response.setReachableWithoutCharging(true);&#10;            response.setRemainingRangeAfterRoute(effectiveRange - totalMiles);&#10;&#10;            // Add intermediate stops to route sequence if any&#10;            if (req.getIntermediates() != null) {&#10;                for (int i = 0; i &lt; req.getIntermediates().size(); i++) {&#10;                    FindRequest.LatLng intermediate = req.getIntermediates().get(i);&#10;                    response.getRouteSequence().add(new FindResponse.RoutePoint(&#10;                        intermediate.latitude, intermediate.longitude, &quot;intermediate&quot;&#10;                    ));&#10;                }&#10;            }&#10;&#10;            // Add destination to route sequence&#10;            response.getRouteSequence().add(new FindResponse.RoutePoint(&#10;                req.getDestination().latitude, req.getDestination().longitude, &quot;destination&quot;&#10;            ));&#10;&#10;            return response;&#10;        }&#10;&#10;        // Need charging - recursively find charging stations and plan route&#10;        // Track remaining intermediate stops (initially all of them)&#10;        List&lt;FindRequest.LatLng&gt; remainingIntermediates = req.getIntermediates() != null ?&#10;            new ArrayList&lt;&gt;(req.getIntermediates()) : new ArrayList&lt;&gt;();&#10;&#10;        return findChargingStopsRecursively(req, polyline, effectiveRange, fullRange, response, remainingIntermediates);&#10;    }&#10;&#10;    private FindResponse findChargingStopsRecursively(FindRequest req, List&lt;double[]&gt; polyline,&#10;                                                     double currentEffectiveRange, double fullRange,&#10;                                                     FindResponse response, List&lt;FindRequest.LatLng&gt; remainingIntermediates) throws Exception {&#10;&#10;        double accumulatedMiles = 0;&#10;        int lastReachableIndex = 0;&#10;        List&lt;FindRequest.LatLng&gt; reachedIntermediates = new ArrayList&lt;&gt;();&#10;&#10;        // Iterate through polyline points&#10;        for (int i = 1; i &lt; polyline.size(); i++) {&#10;            double[] previousPoint = polyline.get(i - 1);&#10;            double[] currentPoint = polyline.get(i);&#10;            double segmentMiles = haversineMiles(previousPoint[0], previousPoint[1],&#10;                    currentPoint[0], currentPoint[1]);&#10;            accumulatedMiles += segmentMiles;&#10;&#10;            if (accumulatedMiles &lt;= currentEffectiveRange) {&#10;                lastReachableIndex = i;&#10;&#10;                // Check if we've reached any intermediate stops at this point&#10;                List&lt;FindRequest.LatLng&gt; justReached = checkAndUpdateReachedIntermediates(currentPoint, remainingIntermediates);&#10;                reachedIntermediates.addAll(justReached);&#10;            } else {&#10;                // Add any intermediate stops we reached before needing to charge&#10;                for (FindRequest.LatLng reached : reachedIntermediates) {&#10;                    response.getRouteSequence().add(new FindResponse.RoutePoint(&#10;                        reached.latitude, reached.longitude, &quot;intermediate&quot;&#10;                    ));&#10;                }&#10;&#10;                // Cannot reach current point, search for charging station at last reachable point&#10;                double[] searchPoint = polyline.get(lastReachableIndex);&#10;                FindResponse.Stop chargingStation = searchForChargingStation(searchPoint[0], searchPoint[1]);&#10;&#10;                if (chargingStation == null) {&#10;                    // No station found, try previous polyline points with distance-based search to avoid gaps&#10;                    // Instead of skipping fixed number of points, skip based on distance to ensure coverage&#10;                    double searchRadiusKm = 10.0; // Our search radius is 10km (7km half-radius × 2)&#10;                    double maxGapKm = searchRadiusKm * 0.8; // Allow 80% overlap (8km gaps max)&#10;&#10;                    double accumulatedDistance = 0;&#10;                    for (int j = lastReachableIndex - 1; j &gt;= 0 &amp;&amp; j &gt;= lastReachableIndex - 300; j--) {&#10;                        double[] currentSearchPoint = polyline.get(j);&#10;                        double[] previousSearchPoint = polyline.get(j + 1);&#10;&#10;                        // Calculate distance from previous search point&#10;                        double segmentDistanceKm = haversineMiles(currentSearchPoint[0], currentSearchPoint[1],&#10;                                previousSearchPoint[0], previousSearchPoint[1]) * KM_PER_MILE;&#10;                        accumulatedDistance += segmentDistanceKm;&#10;&#10;                        // Only search if we've moved far enough to avoid too much overlap&#10;                        if (accumulatedDistance &gt;= maxGapKm) {&#10;                            chargingStation = searchForChargingStation(currentSearchPoint[0], currentSearchPoint[1]);&#10;                            if (chargingStation != null) {&#10;                                System.out.println(&quot;Found charging station at polyline point &quot; + j +&#10;                                    &quot; (distance gap: &quot; + String.format(&quot;%.2f&quot;, accumulatedDistance) + &quot; km)&quot;);&#10;                                break;&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                if (chargingStation == null) {&#10;                    response.setReachableWithoutCharging(false);&#10;                    response.setRemainingRangeAfterRoute(0);&#10;                    // Add final destination even if unreachable for route visualization&#10;                    response.getRouteSequence().add(new FindResponse.RoutePoint(&#10;                        req.getDestination().latitude, req.getDestination().longitude, &quot;destination&quot;&#10;                    ));&#10;                    return response;&#10;                }&#10;&#10;                response.getStops().add(chargingStation);&#10;&#10;                // Add charging station to route sequence&#10;                response.getRouteSequence().add(new FindResponse.RoutePoint(&#10;                    chargingStation.getLat(), chargingStation.getLon(), &quot;charging_station&quot;&#10;                ));&#10;&#10;                // Calculate new route from charging station to destination&#10;                FindRequest newRequest = new FindRequest();&#10;                FindRequest.LatLng stationLocation = new FindRequest.LatLng();&#10;                stationLocation.latitude = chargingStation.getLat();&#10;                stationLocation.longitude = chargingStation.getLon();&#10;                newRequest.setOrigin(stationLocation);&#10;                newRequest.setDestination(req.getDestination());&#10;&#10;                // Only include remaining intermediate stops that haven't been reached yet&#10;                if (!remainingIntermediates.isEmpty()) {&#10;                    newRequest.setIntermediates(new ArrayList&lt;&gt;(remainingIntermediates));&#10;                }&#10;&#10;                // After charging, range is restored to fullRange * chargePercent with buffer applied&#10;                double newRange = fullRange * chargePercent;&#10;                double newEffectiveRange = newRange * (1 - bufferPercent);&#10;                newRequest.setCurrentRangeMiles(newRange);&#10;                // Set SOC to chargePercent * 100 (e.g., 80% charge)&#10;                newRequest.setSoc(chargePercent * 100);&#10;&#10;                // Get new route from station to destination (with remaining intermediates)&#10;                Map&lt;String, Object&gt; newRouteData = callGoogleRoutesApi(newRequest);&#10;                if (newRouteData == null) {&#10;                    throw new RuntimeException(&quot;No route from charging station to destination&quot;);&#10;                }&#10;&#10;                double remainingMeters = ((Number) newRouteData.getOrDefault(&quot;distanceMeters&quot;, 0)).doubleValue();&#10;                double remainingMiles = remainingMeters / 1609.344;&#10;                List&lt;double[]&gt; newPolyline = (List&lt;double[]&gt;) newRouteData.get(&quot;polyline&quot;);&#10;&#10;                if (newEffectiveRange &gt;= remainingMiles) {&#10;                    // Can reach destination from this charging station&#10;                    response.setReachableWithoutCharging(true);&#10;                    response.setRemainingRangeAfterRoute(newEffectiveRange - remainingMiles);&#10;&#10;                    // Add any remaining intermediate stops to route sequence&#10;                    if (remainingIntermediates != null) {&#10;                        for (FindRequest.LatLng intermediate : remainingIntermediates) {&#10;                            response.getRouteSequence().add(new FindResponse.RoutePoint(&#10;                                intermediate.latitude, intermediate.longitude, &quot;intermediate&quot;&#10;                            ));&#10;                        }&#10;                    }&#10;&#10;                    // Add destination to route sequence&#10;                    response.getRouteSequence().add(new FindResponse.RoutePoint(&#10;                        req.getDestination().latitude, req.getDestination().longitude, &quot;destination&quot;&#10;                    ));&#10;&#10;                    return response;&#10;                } else {&#10;                    // Need more charging stations, continue recursively with remaining intermediates&#10;                    return findChargingStopsRecursively(newRequest, newPolyline, newEffectiveRange, fullRange, response, remainingIntermediates);&#10;                }&#10;            }&#10;        }&#10;&#10;        // If we reach here, the route is complete without needing more charging&#10;        // Add any remaining intermediate stops that were reached&#10;        for (FindRequest.LatLng reached : reachedIntermediates) {&#10;            response.getRouteSequence().add(new FindResponse.RoutePoint(&#10;                reached.latitude, reached.longitude, &quot;intermediate&quot;&#10;            ));&#10;        }&#10;&#10;        // Add remaining intermediate stops if any&#10;        if (remainingIntermediates != null) {&#10;            for (FindRequest.LatLng intermediate : remainingIntermediates) {&#10;                response.getRouteSequence().add(new FindResponse.RoutePoint(&#10;                    intermediate.latitude, intermediate.longitude, &quot;intermediate&quot;&#10;                ));&#10;            }&#10;        }&#10;&#10;        // Add destination to route sequence&#10;        response.getRouteSequence().add(new FindResponse.RoutePoint(&#10;            req.getDestination().latitude, req.getDestination().longitude, &quot;destination&quot;&#10;        ));&#10;&#10;        response.setReachableWithoutCharging(true);&#10;        return response;&#10;    }&#10;&#10;    /**&#10;     * Check if the current point is close to any remaining intermediate stops&#10;     * and remove them from the remaining list if reached&#10;     */&#10;    private List&lt;FindRequest.LatLng&gt; checkAndUpdateReachedIntermediates(double[] currentPoint, List&lt;FindRequest.LatLng&gt; remainingIntermediates) {&#10;        double reachThresholdMiles = 1.0; // Consider intermediate reached if within 1 mile&#10;&#10;        List&lt;FindRequest.LatLng&gt; justReached = new ArrayList&lt;&gt;();&#10;        Iterator&lt;FindRequest.LatLng&gt; iterator = remainingIntermediates.iterator();&#10;        while (iterator.hasNext()) {&#10;            FindRequest.LatLng intermediate = iterator.next();&#10;            double distance = haversineMiles(currentPoint[0], currentPoint[1],&#10;                    intermediate.latitude, intermediate.longitude);&#10;&#10;            if (distance &lt;= reachThresholdMiles) {&#10;                justReached.add(intermediate);&#10;                iterator.remove(); // Remove this intermediate as we've reached it&#10;                System.out.println(&quot;Reached intermediate stop at: &quot; + intermediate.latitude + &quot;, &quot; + intermediate.longitude);&#10;            }&#10;        }&#10;&#10;        return justReached;&#10;    }&#10;&#10;    private Map&lt;String, Object&gt; callGoogleRoutesApi(FindRequest req) {&#10;        String url = &quot;https://routes.googleapis.com/directions/v2:computeRoutes&quot;;&#10;&#10;        // Create request payload matching the exact structure from your curl example&#10;        Map&lt;String, Object&gt; payload = new HashMap&lt;&gt;();&#10;&#10;        Map&lt;String, Object&gt; origin = Map.of(&#10;                &quot;location&quot;, Map.of(&#10;                        &quot;latLng&quot;, Map.of(&#10;                                &quot;latitude&quot;, req.getOrigin().latitude,&#10;                                &quot;longitude&quot;, req.getOrigin().longitude&#10;                        )&#10;                )&#10;        );&#10;&#10;        Map&lt;String, Object&gt; destination = Map.of(&#10;                &quot;location&quot;, Map.of(&#10;                        &quot;latLng&quot;, Map.of(&#10;                                &quot;latitude&quot;, req.getDestination().latitude,&#10;                                &quot;longitude&quot;, req.getDestination().longitude&#10;                        )&#10;                )&#10;        );&#10;&#10;        payload.put(&quot;origin&quot;, origin);&#10;        payload.put(&quot;destination&quot;, destination);&#10;&#10;        // Add intermediates if provided&#10;        if (req.getIntermediates() != null &amp;&amp; !req.getIntermediates().isEmpty()) {&#10;            List&lt;Map&lt;String, Object&gt;&gt; intermediates = new ArrayList&lt;&gt;();&#10;            for (FindRequest.LatLng intermediate : req.getIntermediates()) {&#10;                Map&lt;String, Object&gt; intermediateLocation = Map.of(&#10;                        &quot;location&quot;, Map.of(&#10;                                &quot;latLng&quot;, Map.of(&#10;                                        &quot;latitude&quot;, intermediate.latitude,&#10;                                        &quot;longitude&quot;, intermediate.longitude&#10;                                )&#10;                        )&#10;                );&#10;                intermediates.add(intermediateLocation);&#10;            }&#10;            payload.put(&quot;intermediates&quot;, intermediates);&#10;        }&#10;&#10;        payload.put(&quot;travelMode&quot;, &quot;DRIVE&quot;);&#10;        payload.put(&quot;routingPreference&quot;, &quot;TRAFFIC_AWARE_OPTIMAL&quot;);&#10;//        payload.put(&quot;polylineQuality&quot;, &quot;HIGH_QUALITY&quot;);&#10;&#10;        // Set headers exactly as specified in your curl example&#10;        HttpHeaders headers = new HttpHeaders();&#10;        headers.setContentType(MediaType.APPLICATION_JSON);&#10;        headers.set(&quot;X-Goog-Api-Key&quot;, googleApiKey);&#10;        headers.set(&quot;X-Goog-FieldMask&quot;, &quot;routes.distanceMeters,routes.polyline.encodedPolyline&quot;);&#10;&#10;        HttpEntity&lt;Map&lt;String, Object&gt;&gt; entity = new HttpEntity&lt;&gt;(payload, headers);&#10;&#10;        try {&#10;            ResponseEntity&lt;String&gt; response = restTemplate.postForEntity(url, entity, String.class);&#10;            if (!response.getStatusCode().is2xxSuccessful()) {&#10;                System.err.println(&quot;Google Routes API error: &quot; + response.getStatusCode());&#10;                return null;&#10;            }&#10;&#10;            // Parse JSON response&#10;            com.fasterxml.jackson.databind.ObjectMapper objectMapper = new com.fasterxml.jackson.databind.ObjectMapper();&#10;            com.fasterxml.jackson.databind.JsonNode root = objectMapper.readTree(response.getBody());&#10;&#10;            com.fasterxml.jackson.databind.JsonNode routeNode = root.path(&quot;routes&quot;).get(0);&#10;            if (routeNode == null) return null;&#10;&#10;            double distanceMeters = routeNode.path(&quot;distanceMeters&quot;).asDouble(0);&#10;            String encodedPolyline = routeNode.path(&quot;polyline&quot;).path(&quot;encodedPolyline&quot;).asText();&#10;&#10;            List&lt;double[]&gt; polyline = new ArrayList&lt;&gt;();&#10;            if (encodedPolyline != null &amp;&amp; !encodedPolyline.isEmpty()) {&#10;                polyline = Polyline.decode(encodedPolyline);&#10;            }&#10;&#10;            Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();&#10;            result.put(&quot;distanceMeters&quot;, distanceMeters);&#10;            result.put(&quot;polyline&quot;, polyline);&#10;            System.out.println(&quot;polyline &quot; + polyline);&#10;            result.put(&quot;encodedPolyline&quot;, encodedPolyline); // Add encoded polyline to result&#10;&#10;            return result;&#10;&#10;        } catch (Exception ex) {&#10;            System.err.println(&quot;Error calling Google Routes API: &quot; + ex.getMessage());&#10;            ex.printStackTrace();&#10;            return null;&#10;        }&#10;    }&#10;&#10;    private FindResponse.Stop searchForChargingStation(double lat, double lon) {&#10;        double halfKm = 7.0; // half of 5 km (so total box = 10 km height × 10 km width)&#10;&#10;        // Approximate conversion factors&#10;        double kmPerDegLat = 110.574; // ~ km per degree latitude&#10;        double kmPerDegLon = 111.320 * Math.cos(Math.toRadians(lat)); // ~ km per degree longitude at this latitude&#10;&#10;        // Convert km to degrees&#10;        double dLat = halfKm / kmPerDegLat;&#10;        double dLon = halfKm / kmPerDegLon;&#10;&#10;        // Bounding box corners&#10;        double neLat = lat + dLat;&#10;        double neLon = lon + dLon;&#10;        double swLat = lat - dLat;&#10;        double swLon = lon - dLon;&#10;&#10;        // Create payload matching your curl example structure&#10;        Map&lt;String, Object&gt; stationList = new HashMap&lt;&gt;();&#10;        stationList.put(&quot;screen_width&quot;, 417.5);&#10;        stationList.put(&quot;screen_height&quot;, 548);&#10;        stationList.put(&quot;ne_lat&quot;, neLat);&#10;        stationList.put(&quot;ne_lon&quot;, neLon);&#10;        stationList.put(&quot;sw_lat&quot;, swLat);&#10;        stationList.put(&quot;sw_lon&quot;, swLon);&#10;        stationList.put(&quot;page_size&quot;, 10);&#10;        stationList.put(&quot;page_offset&quot;, &quot;&quot;);&#10;        stationList.put(&quot;sort_by&quot;, &quot;distance&quot;);&#10;        stationList.put(&quot;reference_lat&quot;, lat);&#10;        stationList.put(&quot;reference_lon&quot;, lon);&#10;        stationList.put(&quot;include_map_bound&quot;, true);&#10;&#10;        // Add filters for available DC fast charging stations&#10;        Map&lt;String, Object&gt; filter = new HashMap&lt;&gt;();&#10;        filter.put(&quot;status_available&quot;, true);&#10;        filter.put(&quot;dc_fast_charging&quot;, true);&#10;        stationList.put(&quot;filter&quot;, filter);&#10;        stationList.put(&quot;bound_output&quot;, true);&#10;&#10;        Map&lt;String, Object&gt; payload = Map.of(&quot;station_list&quot;, stationList);&#10;&#10;        // Set headers exactly as specified in your curl example&#10;        HttpHeaders headers = new HttpHeaders();&#10;        headers.setContentType(MediaType.APPLICATION_JSON);&#10;        headers.set(&quot;accept&quot;, &quot;*/*&quot;);&#10;        headers.set(&quot;accept-language&quot;, &quot;en-GB&quot;);&#10;        HttpEntity&lt;Map&lt;String, Object&gt;&gt; entity = new HttpEntity&lt;&gt;(payload, headers);&#10;&#10;        try {&#10;            ResponseEntity&lt;String&gt; response = restTemplate.postForEntity(chargepointApiUrl, entity, String.class);&#10;            System.out.println(&quot;pk&quot; + response);&#10;            if (!response.getStatusCode().is2xxSuccessful()) {&#10;                System.err.println(&quot;ChargePoint API error: &quot; + response.getStatusCode());&#10;                return null;&#10;            }&#10;&#10;            com.fasterxml.jackson.databind.ObjectMapper objectMapper = new com.fasterxml.jackson.databind.ObjectMapper();&#10;            com.fasterxml.jackson.databind.JsonNode root = objectMapper.readTree(response.getBody());&#10;&#10;            com.fasterxml.jackson.databind.JsonNode stations = root.path(&quot;station_list&quot;).path(&quot;stations&quot;);&#10;            if (stations.isArray() &amp;&amp; stations.size() &gt; 0) {&#10;                // Return the first (closest) station for the charging route logic&#10;                // But we'll add all stations to a separate list for frontend display&#10;                com.fasterxml.jackson.databind.JsonNode firstStation = stations.get(0);&#10;&#10;                double stationLat = firstStation.path(&quot;lat&quot;).asDouble(firstStation.path(&quot;latitude&quot;).asDouble());&#10;                double stationLon = firstStation.path(&quot;lon&quot;).asDouble(firstStation.path(&quot;longitude&quot;).asDouble());&#10;                String stationName = firstStation.path(&quot;name&quot;).asText(&#10;                        firstStation.path(&quot;station_name&quot;).asText(&#10;                            firstStation.path(&quot;name1&quot;).asText(&quot;ChargePoint Station&quot;)&#10;                        )&#10;                );&#10;                Integer deviceId = firstStation.path(&quot;device_id&quot;).asInt(0);&#10;&#10;                FindResponse.Stop stop = new FindResponse.Stop();&#10;                stop.setLat(stationLat);&#10;                stop.setLon(stationLon);&#10;                stop.setStationName(stationName);&#10;                stop.setDistanceFromRoutePointMiles(haversineMiles(lat, lon, stationLat, stationLon));&#10;                stop.setDeviceId(deviceId);&#10;&#10;                // Store the complete raw station data for the primary station&#10;                try {&#10;                    Object rawFirstStation = objectMapper.treeToValue(firstStation, Object.class);&#10;                    stop.setRawStationData(rawFirstStation);&#10;                } catch (Exception e) {&#10;                    System.err.println(&quot;Error converting first station to raw data: &quot; + e.getMessage());&#10;                }&#10;&#10;                // Store all raw stations for this search location&#10;                List&lt;Object&gt; allRawStations = new ArrayList&lt;&gt;();&#10;                for (com.fasterxml.jackson.databind.JsonNode station : stations) {&#10;                    try {&#10;                        Object rawStation = objectMapper.treeToValue(station, Object.class);&#10;                        allRawStations.add(rawStation);&#10;                    } catch (Exception e) {&#10;                        System.err.println(&quot;Error converting station to raw data: &quot; + e.getMessage());&#10;                    }&#10;                }&#10;&#10;                // Add all raw stations to the main stop for reference&#10;                stop.setAllRawStations(allRawStations);&#10;                return stop;&#10;            }&#10;&#10;            return null;&#10;&#10;        } catch (Exception ex) {&#10;            System.err.println(&quot;Error calling ChargePoint API: &quot; + ex.getMessage());&#10;            ex.printStackTrace();&#10;            return null;&#10;        }&#10;    }&#10;&#10;    private double haversineMiles(double lat1, double lon1, double lat2, double lon2) {&#10;        double R = 3958.8; // Earth radius in miles&#10;        double dLat = Math.toRadians(lat2 - lat1);&#10;        double dLon = Math.toRadians(lon2 - lon1);&#10;        double a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +&#10;                Math.cos(Math.toRadians(lat1)) * Math.cos(Math.toRadians(lat2)) *&#10;                Math.sin(dLon / 2) * Math.sin(dLon / 2);&#10;        double c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));&#10;        return R * c;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>